<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>โปรแกรมคำนวณระดับก้นท่อ</title>

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Sarabun:wght@400;700&display=swap" rel="stylesheet">

    <style>
        body {
            font-family: 'Sarabun', sans-serif;
            padding-top: 100px;
            /* Add padding for fixed navbar */
            margin-top: 20px;
        }

        #apptitle {
            font-size: 1.25rem;
            /* Adjusted for better fit */
        }

        .table thead th {
            text-align: center;
            vertical-align: middle;
            background-color: #e9ecef;
            font-size: 0.85rem;
        }

        .table tbody td {
            text-align: center;
            vertical-align: middle;
            padding: 0.25rem;
        }

        .table input[type="number"] {
            width: 100%;
            border: 1px solid #ced4da;
            border-radius: 0.25rem;
            text-align: center;
            padding: 0.375rem;
        }

        .table input:read-only {
            background-color: #e9ecef;
            font-weight: bold;
        }

        .highlight input:read-only {
            background-color: #d1e7dd;
            /* Bootstrap success light */
            color: #0f5132;
        }

        .table-set {
            background-color: white;
            padding: 20px;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            margin-bottom: 25px;
        }

        /* Hide the non-functional navbar handle */
        #navbar-handle-wrapper {
            display: none;
        }
    </style>
</head>

<body class="bg-dark text-light">
    <!-- ส่วนของ Navbar -->
    <nav class="navbar navbar-expand-lg navbar-dark bg-primary fixed-top shadow-sm py-2">
        <div class="container">

            <a class="navbar-brand" href="https://dds.bangkok.go.th">
                <img src="https://dds.bangkok.go.th/images/DDS_Logo_500.png" alt="Logo" style="height: 40px;">
            </a>

            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarContent"
                aria-controls="navbarContent" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>

            <div class="collapse navbar-collapse" id="navbarContent">
                <div class="row w-100 align-items-center g-3 ms-auto">

                    <div class="col-12 col-lg-7 text-center">
                        <span class="h5 fw-bold text-white my-3 my-lg-0">
                            ระบบคำนวนขนาดและระดับก้นท่อระบายน้ำ
                        </span>
                    </div>

                    <div class="col-12 col-lg-5">
                        <div class="row g-2">
                            <div class="col-12 col-sm-6">
                                <a href="#" class="btn btn-light w-100">{{ session.get('user_name', session['user'])
                                    }}</a>
                            </div>
                            <div class="col-12 col-sm-6">
                                <a href="{{ url_for('logout') }}" class="btn btn-danger text-light w-100">ออกจากระบบ</a>
                            </div>
                        </div>
                    </div>

                </div>
            </div>
        </div>
    </nav>

    <main class="container text-dark">
        <div class="table-set">
            <div class="d-flex justify-content-between align-items-center mb-3">
                <h4 class="mb-0">ตารางคำนวณค่าระดับท่อ</h4>
                <button class="btn btn-success" onclick="addTableRow()"><i class="bi bi-plus-lg"></i> เพิ่มแถว</button>
            </div>

            <div class="row">
                <div class="col-12">
                    <div class="table-responsive">
                        <table class="table table-bordered" id="main-calc-table">
                            <thead>
                                <tr>
                                    <th style="width: 5%;" rowspan="2">ลบ</th>
                                    <th style="width: 8%;">1</th>
                                    <th style="width: 8%;">2</th>
                                    <th style="width: 8%;">3</th>
                                    <th style="width: 8%;">4</th>
                                    <th class="highlight" style="width: 10%;">5</th>
                                    <th style="width: 8%;">6</th>
                                    <th style="width: 7%;">7</th>
                                    <th style="width: 8%;">8</th>
                                    <th class="highlight" style="width: 10%;">9</th>
                                    <th style="width: 10%;">10</th>
                                    <th class="highlight" style="width: 10%;">11</th>
                                </tr>
                                <tr>
                                    <th>จุดเริ่ม</th>
                                    <th>ค่าระดับดิน</th>
                                    <th>ดินถมหลังท่อ</th>
                                    <th>ขนาดท่อ</th>
                                    <th>ค่าระดับก้นท่อ</th>
                                    <th>ความยาวท่อ</th>
                                    <th>ความชัน (+/-)</th>
                                    <th>ความลาดชัน (1:X)</th>
                                    <th>ค่าต่างระดับ</th>
                                    <th>จุดเชื่อม</th>
                                    <th>ระดับก้นท่อจุดเชื่อม</th>
                                </tr>
                            </thead>
                            <tbody id="calculation-body">
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>

            <!-- ปุ่มยืนยันข้อมูล -->
            <div class="row justify-content-center g-2">
                <div class="col-12 col-sm-9">
                    <a href="{{ url_for('report', project_id=project.id) if project else url_for('report') }}"
                        class="btn btn-primary w-100"><i class="bi bi-check-circle me-1"></i>ยืนยันข้อมูล</a>
                </div>
                <div class="col-12 col-sm-3">
                    <a href="{{ url_for('cal_table', project_id=project.id) if project else url_for('cal_table') }}"
                        class="btn btn-danger w-100"><i class="bi bi-arrow-counterclockwise me-1"></i>ย้อนกลับ</a>
                </div>
            </div>

        </div>
    </main>


    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>

    <script>
        function adjustBodyPadding() {
            const navbar = document.getElementById('mainNavbar');
            if (navbar) {
                const navbarHeight = navbar.offsetHeight;
                document.body.style.paddingTop = navbarHeight + 'px';
            }
        }

        // เรียกใช้ฟังก์ชันเมื่อหน้าเว็บโหลดเสร็จ
        document.addEventListener('DOMContentLoaded', adjustBodyPadding);

        // เรียกใช้ฟังก์ชันอีกครั้งเมื่อมีการปรับขนาดหน้าจอ (เช่น หมุนมือถือ)
        window.addEventListener('resize', adjustBodyPadding);
    </script>

    <script>
        const mainBody = document.getElementById('calculation-body');
        let knownNodes = new Set();
        let pipeData = []; // Data for this table
        let fullPipeNetwork = []; // Data from Map & Table (localStorage)

        // --- Database Persistence ---
        const projectId = {{ project.id if project else 'null' }};
        let saveTimeout;

        function saveDebounced() {
            if (!projectId) return; // Only save if project context exists

            clearTimeout(saveTimeout);
            saveTimeout = setTimeout(async () => {
                try {
                    await fetch(`/api/save_project_data/${projectId}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ invert_data: pipeData })
                    });
                    console.log('Saved to DB');
                } catch (e) {
                    console.error('Save failed', e);
                }
            }, 1000); // Save after 1 second of inactivity
        }

        // Inject data from Backend
        const projectGroundLevel = parseFloat("{{ improved_level }}") || 0;

        // --- Core Calculation Logic ---
        function recalculateAll() {
            const rows = mainBody.querySelectorAll('tr');
            let previousInvertConnect = null;
            let previousPipeSize = 0; // Track previous pipe size
            const updatedPipeData = [];

            rows.forEach((row, index) => {
                const inputs = {
                    startNode: row.querySelector('.start-node-select'),
                    groundLevel: row.querySelector('.ground-level'),
                    soilCover: row.querySelector('.soil-cover'),
                    pipeSize: row.querySelector('.pipe-size'),
                    pipeInvert: row.querySelector('.pipe-invert'),
                    pipeLength: row.querySelector('.pipe-length'),
                    slopeSign: row.querySelector('.slope-sign'),
                    slopeValue: row.querySelector('.slope-value'),
                    levelDiff: row.querySelector('.level-diff'),
                    endNode: row.querySelector('.end-node-select'),
                    invertConnect: row.querySelector('.invert-connect')
                };

                // Current Pipe Size
                const currentPipeSize = parseFloat(inputs.pipeSize.value) || 0;

                // 0. Update Data Object
                const existingData = pipeData[index] || {};
                const rowData = {
                    ...existingData,
                    id: existingData.id || '',
                    q: existingData.q || 0,
                    status: existingData.status || 'Pending',
                    startNode: inputs.startNode.value,
                    groundLevel: inputs.groundLevel.value,
                    soilCover: inputs.soilCover.value,
                    size: inputs.pipeSize.value,
                    length: inputs.pipeLength.value,
                    slopeSign: inputs.slopeSign.value,
                    slopeValue: inputs.slopeValue.value,
                    endNode: inputs.endNode.value
                };

                updatedPipeData.push(rowData);


                // 1. Calculate Pipe Invert (Col 5)
                let pipeInvertValue;
                if (index === 0) {
                    const groundLevel = parseFloat(inputs.groundLevel.value) || 0;
                    const soilCover = parseFloat(inputs.soilCover.value) || 0;
                    pipeInvertValue = groundLevel - soilCover - currentPipeSize;
                    inputs.pipeInvert.value = pipeInvertValue.toFixed(3);
                    inputs.groundLevel.readOnly = false;
                } else {
                    if (previousInvertConnect !== null) {
                        // Formula: PrevInvertConnect + PrevSize - CurrentSize
                        // Matches the crown (soffit) levels
                        pipeInvertValue = previousInvertConnect + previousPipeSize - currentPipeSize;
                    } else {
                        // Fallback logic if flow is broken (shouldn't happen in valid sequence)
                        const groundLevel = parseFloat(inputs.groundLevel.value) || 0;
                        const soilCover = parseFloat(inputs.soilCover.value) || 0;
                        pipeInvertValue = groundLevel - soilCover - currentPipeSize;
                    }

                    inputs.pipeInvert.value = pipeInvertValue.toFixed(3);
                    inputs.groundLevel.readOnly = true;
                }

                // 2. Calculate Level Difference (Col 9)
                const pipeLength = parseFloat(inputs.pipeLength.value) || 0;
                const slopeValNum = parseFloat(inputs.slopeValue.value) || 0;
                let levelDiffValue = 0;
                if (slopeValNum !== 0) {
                    levelDiffValue = pipeLength / slopeValNum;
                }

                const sign = inputs.slopeSign.value === '-' ? -1 : 1;
                levelDiffValue *= sign;
                inputs.levelDiff.value = levelDiffValue.toFixed(3);

                // 3. Calculate Invert at Connection (Col 11)
                const invertConnectValue = pipeInvertValue + levelDiffValue;
                if (inputs.invertConnect) {
                    inputs.invertConnect.value = invertConnectValue.toFixed(3);
                }

                // Update the rowData with calculated values before saving
                rowData.pipeInvert = pipeInvertValue.toFixed(3);
                rowData.levelDiff = levelDiffValue.toFixed(3);
                rowData.invertConnect = invertConnectValue.toFixed(3);

                // Store for next row
                previousInvertConnect = invertConnectValue;
                previousPipeSize = currentPipeSize;
            });

            // Save updated data to Global Variable and LocalStorage
            pipeData = updatedPipeData;
            // Save updated data to Global Variable and LocalStorage / DB
            pipeData = updatedPipeData;
            localStorage.setItem('calTableData', JSON.stringify(pipeData));

            // Trigger DB Save
            saveDebounced();
        }


        // --- Row Management ---
        function generateNodeOptions(selectedNode, validNodes = null) {
            let options = '';

            // If validNodes is provided, use it. Otherwise use all knownNodes.
            let nodesToRender = validNodes ? Array.from(validNodes) : Array.from(knownNodes);

            // Always ensure the currently selected node is in the list
            if (selectedNode && !nodesToRender.includes(selectedNode)) {
                nodesToRender.push(selectedNode);
            }

            const sortedNodes = nodesToRender.sort((a, b) => {
                const na = parseInt(a);
                const nb = parseInt(b);
                if (!isNaN(na) && !isNaN(nb)) return na - nb;
                return a.localeCompare(b);
            });

            sortedNodes.forEach(node => {
                const isSelected = String(node) === String(selectedNode) ? 'selected' : '';
                options += `<option value="${node}" ${isSelected}>${node}</option>`;
            });
            return options;
        }

        // Helper: Find valid connected nodes given a start node
        function getConnectedNodes(node) {
            if (!fullPipeNetwork || fullPipeNetwork.length === 0) return null; // No network data

            const connected = new Set();
            fullPipeNetwork.forEach(pipe => {
                // Check forward connection (Start -> End)
                if (String(pipe.startNode) === String(node)) {
                    connected.add(pipe.endNode);
                }
                // Check reverse connection (End -> Start)
                if (String(pipe.endNode) === String(node)) {
                    connected.add(pipe.startNode);
                }
            });
            return connected.size > 0 ? connected : null;
        }

        // Helper: Find matching pipe data (Bidirectional)
        function getPipeInfo(nodeA, nodeB) {
            if (!fullPipeNetwork) return null;
            return fullPipeNetwork.find(pipe =>
                (String(pipe.startNode) === String(nodeA) && String(pipe.endNode) === String(nodeB)) ||
                (String(pipe.startNode) === String(nodeB) && String(pipe.endNode) === String(nodeA))
            );
        }

        function onStartNodeChange(selectElement) {
            const row = selectElement.closest('tr');
            const startNode = selectElement.value;
            const endNodeSelect = row.querySelector('.end-node-select');
            const currentEndNode = endNodeSelect.value;

            // Filter End Nodes
            const validEndNodes = getConnectedNodes(startNode);

            // Regenerate End Node Options
            if (validEndNodes) {
                endNodeSelect.innerHTML = generateNodeOptions(null, validEndNodes);

                // If there is only one option, select it automatically
                if (validEndNodes.size === 1) {
                    endNodeSelect.value = Array.from(validEndNodes)[0];
                    // Trigger change to update length/size
                    onEndNodeChange(endNodeSelect);
                } else {
                    endNodeSelect.value = ""; // Clear selection if multiple options and previous one invalid
                }

            } else {
                // Fallback to all known nodes
                endNodeSelect.innerHTML = generateNodeOptions(currentEndNode);
            }

            recalculateAll();
        }

        function onEndNodeChange(selectElement) {
            const row = selectElement.closest('tr');
            const startNode = row.querySelector('.start-node-select').value;
            const endNode = selectElement.value;

            // Try to auto-fill length and size
            const match = getPipeInfo(startNode, endNode);
            if (match) {
                if (match.length) row.querySelector('.pipe-length').value = match.length;

                // Auto-fill Pipe Size if available in calTableData
                if (match.size && match.size !== '-') {
                    const sizeSelect = row.querySelector('.pipe-size');
                    // Check if the value exists in our fixed options to avoid invalid selection
                    const validSizes = ['0.60', '0.80', '1.00', '1.20', '1.50'];
                    if (validSizes.includes(match.size)) {
                        sizeSelect.value = match.size;
                    }
                }
            }
            recalculateAll();
        }


        function addTableRow(data = null, skipCalc = false) {
            const rowCount = mainBody.rows.length;

            // Default values
            let startNode = rowCount + 1;
            let endNode = rowCount + 2;
            let length = '';
            let size = '1.00';

            // Invert Cal specific defaults
            let groundLevel = '';
            let soilCover = '0.60';
            let slopeSign = '-';
            let slopeValue = '1000';

            if (data) {
                startNode = data.startNode || startNode;
                endNode = data.endNode || endNode;
                length = data.length || '';
                if (data.size && data.size !== '-') size = data.size;

                if (data.groundLevel) groundLevel = data.groundLevel;
                if (data.soilCover) soilCover = data.soilCover;
                if (data.slopeSign) slopeSign = data.slopeSign;
                if (data.slopeValue) slopeValue = data.slopeValue;
            }

            // Auto-populate ground level for first row if value is empty and project level exists
            if (rowCount === 0 && (!groundLevel || groundLevel === '') && projectGroundLevel > 0) {
                groundLevel = projectGroundLevel.toFixed(3);
                // Also ensure we update the data object if we are "fixing" an existing row's data on load?
                // No, addNodes uses 'groundLevel' var to render the input value. 
                // The input value will be picked up by 'recalculateAll' later.
            }

            knownNodes.add(startNode);
            knownNodes.add(endNode);

            // Calculate valid end nodes for initial filtering
            const validEndNodes = getConnectedNodes(startNode);

            // Add to main calculation table
            const newRow = mainBody.insertRow();
            newRow.innerHTML = `
            <td><button class="btn btn-danger btn-sm" onclick="deleteRow(this)"><i class="bi bi-trash"></i></button></td>
            <td>
                <select class="form-select start-node-select" onchange="onStartNodeChange(this)">
                    ${generateNodeOptions(startNode)}
                </select>
            </td>
            <td><input type="number" step="0.10" class="form-control ground-level" placeholder="ระดับดิน" value="${groundLevel}"></td>
            <td><input type="number" step="0.05" class="form-control soil-cover" value="${soilCover}"></td>
            <td>
                <select class="form-select pipe-size">
                    <option value="0.60" ${size == '0.60' ? 'selected' : ''}>ø0.60</option>
                    <option value="0.80" ${size == '0.80' ? 'selected' : ''}>ø0.80</option>
                    <option value="1.00" ${size == '1.00' ? 'selected' : ''}>ø1.00</option>
                    <option value="1.20" ${size == '1.20' ? 'selected' : ''}>ø1.20</option>
                    <option value="1.50" ${size == '1.50' ? 'selected' : ''}>ø1.50</option>
                </select>
            </td>
            <td><input type="number" class="form-control pipe-invert" readonly></td>
            <td><input type="number" step="0.10" class="form-control pipe-length" placeholder="ความยาว" value="${length}"></td>
            <td>
                <select class="form-select slope-sign">
                    <option value="+" ${slopeSign == '+' ? 'selected' : ''}>+</option>
                    <option value="-" ${slopeSign == '-' ? 'selected' : ''}>-</option>
                </select>
            </td>
            <td>
                <select class="form-select slope-value">
                    <option value="750" ${slopeValue == '750' ? 'selected' : ''}>750</option>
                    <option value="1000" ${slopeValue == '1000' ? 'selected' : ''}>1000</option>
                    <option value="1200" ${slopeValue == '1200' ? 'selected' : ''}>1200</option>
                </select>
            </td>
            <td><input type="number" class="form-control level-diff" readonly></td>
            <td>
                 <select class="form-select end-node-select" onchange="onEndNodeChange(this)">
                    ${generateNodeOptions(endNode, validEndNodes)}
                </select>
            </td>
            <td><input type="number" class="form-control invert-connect" readonly></td>
        `;

            if (!skipCalc) recalculateAll();
        }

        function deleteRow(button) {
            const tr = button.closest('tr');
            const index = Array.from(mainBody.children).indexOf(tr);

            if (index > -1) {
                mainBody.deleteRow(index);

                // Remove from data array
                pipeData.splice(index, 1);

                recalculateAll();
            }
        }

        // --- Initial Setup & Event Listener ---
        document.addEventListener('DOMContentLoaded', async () => {
            // Load Strategy: DB -> LocalStorage Fallback

            let loadedData = null;
            let loadedMapData = null;

            if (projectId) {
                try {
                    const response = await fetch(`/api/get_project_data/${projectId}`);
                    const dbData = await response.json();

                    if (dbData.invert_data && dbData.invert_data.length > 0) {
                        loadedData = dbData.invert_data;
                    } else if (dbData.design_data && dbData.design_data.length > 0) {
                        // Use design data from calTable
                        loadedData = dbData.design_data;
                    } else if (dbData.cal_data && dbData.cal_data.length > 0) {
                        // Use calculated pipe data as base for invert
                        loadedData = dbData.cal_data;
                    }
                    // Load full network context from cal_data if available
                    if (dbData.cal_data) {
                        loadedMapData = dbData.cal_data;
                    }
                } catch (e) {
                    console.error('DB Load Error', e);
                }
            }

            // Fallback to LocalStorage if DB didn't provide main data
            if (!loadedData) {
                const lsData = localStorage.getItem('calTableData');
                if (lsData) loadedData = JSON.parse(lsData);
            }

            // Fallback map data
            if (!loadedMapData) {
                const lsMap = localStorage.getItem('calTableData'); // Map usage uses same key currently
                if (lsMap) loadedMapData = JSON.parse(lsMap);
            }

            // Apply Map Data
            if (loadedMapData) {
                fullPipeNetwork = loadedMapData;
            }

            // Apply Pipe Data
            if (loadedData) {
                pipeData = loadedData;

                // Extract Nodes Logic
                pipeData.forEach(p => {
                    if (p.startNode) knownNodes.add(p.startNode);
                    if (p.endNode) knownNodes.add(p.endNode);
                });
                if (fullPipeNetwork.length > 0) {
                    fullPipeNetwork.forEach(p => {
                        if (p.startNode) knownNodes.add(p.startNode);
                        if (p.endNode) knownNodes.add(p.endNode);
                    });
                }

                // Populate Rows
                pipeData.forEach(pipe => {
                    addTableRow(pipe, true);
                });
                recalculateAll();
            } else {
                // Fresh Start
                knownNodes.add(1); knownNodes.add(2);
                addTableRow();
            }
        });

        // Use event delegation for performance. Listen for changes on the container.
        document.getElementById('main-calc-table').addEventListener('input', recalculateAll);
        document.getElementById('main-calc-table').addEventListener('change', recalculateAll);

    </script>
</body>

</html>